[
["app-rstudio.html", "B R and RStudio Help B.1 Installing B.2 RStudio Orientation B.3 R Packages B.4 Working with Tables B.5 Graphics with ggplot2", " B R and RStudio Help R is a powerful, open-source statistical programming language used by both professional and academic data scientists. It is among the computer languages most suited to modern data science, and is growing rapidly in its user base and available packages. Some students may not feel comfortable working in a programming language like R or a console-based application like RStudio, especially if they have used applications primarily through a GUI. This appendix provides a basic bootcamp for R and Rstudio, but cannot be a comprehensive manual on RStudio, and it certainly cannot be one for R. Good places to get more detailed help include: R help manuals Stack Overflow Some of the sections in this appendix are text-based, and some contain little more than links to YouTube videos created by me or someone else. B.1 Installing There are two pieces of software you should install: R https://cran.r-project.org/: this contains the system libraries necessary to run R commands in a terminal on your computer, and contains a few additional helper applications. Install the most recent stable release for your operating system. RStudio https://rstudio.com/products/rstudio/download/ is an integrated application that makes using R considerably easier with text completion, file managment, and some GUI features. Both software are available for Windows, MacOS, and Linux. The videos and screenshots of the application I post will use MacOS; the R code for all systems is the same, and the RStudio interface all systems is very similar with minor differences. B.2 RStudio Orientation The video below gives a very basic introduction to RStudio. There is also a very useful cheat sheet for working with RStudio on the Rstudio website. B.3 R Packages One of the strengths of R is the ability for anyone to write packages. These packages make it easier to read manipulate, and vizualize data; to estimate statistical models; or to communicate results. There are a number of ways to install additional packages. The most straightforward is to use the install.packages() function in the console. The problems in this book are solved with two additional packages1: install.packages(&quot;tidyverse&quot;) # a suite of tools for data manipulation install.packages(&quot;mlogit&quot;) # discrete choice modeling RStudio also contains a GUI interface to install and update packages. Sometimes you want to use a package that has not yet been pushed to CRAN, the international repository of “approved” R packages. This may be because the package is in development, or for one reason or another does not meet CRAN’s standards for completeness, etc. Oftentimes, the package has been made available on GitHub. You can install a package directly from GitHub with the remotes library. One package you will want for the problems in the book is the nhts2017 package on the BYU Transportation GitHub account. This package contains datasets from the 2017 National Household Travel Survey. install.packages(&quot;remotes&quot;) # tools for installing development packages remotes::install_github(&quot;byu-transpolab/nhts2017&quot;) You only need to install a package once on your computer. But every time you want to use a function in a package, you need to load the package with the library() function. To load the tidyverse packages, for instance, library(tidyverse) ## ── Attaching packages ────────────────────────────────────────────────────────────────────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.3.2.9000 ✓ purrr 0.3.4 ## ✓ tibble 3.0.1 ✓ dplyr 0.8.5 ## ✓ tidyr 1.1.0 ✓ stringr 1.4.0 ## ✓ readr 1.3.1 ✓ forcats 0.5.0 ## ── Conflicts ───────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() If you get errors when you run the command above, it means that for some reason you did not install the package correctly. And if you ever get an error like kable(tibble(x = 1:2, y = c(&quot;blue&quot;, &quot;red&quot;))) ## Error in kable(tibble(x = 1:2, y = c(&quot;blue&quot;, &quot;red&quot;))): could not find function &quot;kable&quot; It often means you didn’t load the library. In this case, the kable() function to make pretty tables is part of the knitr package. library(knitr) kable(tibble(x = 1:2, y = c(&quot;blue&quot;, &quot;red&quot;))) x y 1 blue 2 red You can also use a function from a package without loading the library if you use the :: operator, like you did in the remotes::install_github() command earlier. This is handy if you only want to use one function from a package, or if you have two functions from different packages with the same name. For example, when you loaded the tidyverse package, R told you that dplyr::filter() would mask stats::filter(). So if for some reason you wanted to use the filter function from the stats package, you would need to use stats::filter(). B.4 Working with Tables Most data you will work with comes in a tabular form, meaning that the data is formatted in columns of variables and rows of observations. B.4.1 Reading Data Tabular data is often stored in a comma-separated values .csv file. To read a data file like this in R, you can use the read_csv() function included in tidyverse. trips &lt;- read_csv(&quot;data/demo_trips.csv&quot;) ## Parsed with column specification: ## cols( ## houseid = col_double(), ## personid = col_character(), ## trpmiles = col_double(), ## trippurp = col_character() ## ) print(trips) ## # A tibble: 924 x 4 ## houseid personid trpmiles trippurp ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 30182694 01 13.6 HBW ## 2 40532989 02 9.38 HBSOCREC ## 3 40729475 01 5.06 HBSHOP ## 4 40290784 01 0.509 HBSOCREC ## 5 30118876 02 0.599 NHB ## 6 30352119 01 20.3 HBO ## 7 30085077 01 22.5 NHB ## 8 30180962 02 0.581 HBSOCREC ## 9 40155356 01 2.74 HBO ## 10 30069734 01 4.65 NHB ## # … with 914 more rows This function will make a guess as to what the columns types should be. Often we want to keep ID values as characters, even if they are numeric (this preserves leading 0 values, etc.). We can tell read_csv() what types we expect with the col_types argument. trips &lt;- read_csv(&quot;data/demo_trips.csv&quot;, col_types = list(houseid = col_character())) print(trips) ## # A tibble: 924 x 4 ## houseid personid trpmiles trippurp ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 30182694 01 13.6 HBW ## 2 40532989 02 9.38 HBSOCREC ## 3 40729475 01 5.06 HBSHOP ## 4 40290784 01 0.509 HBSOCREC ## 5 30118876 02 0.599 NHB ## 6 30352119 01 20.3 HBO ## 7 30085077 01 22.5 NHB ## 8 30180962 02 0.581 HBSOCREC ## 9 40155356 01 2.74 HBO ## 10 30069734 01 4.65 NHB ## # … with 914 more rows You can also write tables back to .csv with the write_csv() command. B.4.2 Modifying and Summarizing Tables In much of this section, we will work with the nhts_trips dataset of trips from the 2017 National Household Travel Survey in the nhts2017 package you installed from GitHub above. library(nhts2017) trips &lt;- nhts_trips trips ## # A tibble: 923,572 x 62 ## houseid personid tdtrpnum strttime endtime trvlcmin ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;dttm&gt; &lt;dbl+lb&gt; ## 1 300000… 01 1 2017-10-10 10:00:00 2017-10-10 10:15:00 15 ## 2 300000… 01 2 2017-10-10 15:10:00 2017-10-10 15:30:00 20 ## 3 300000… 02 1 2017-10-10 07:00:00 2017-10-10 09:00:00 120 ## 4 300000… 02 2 2017-10-10 18:00:00 2017-10-10 20:30:00 150 ## 5 300000… 03 1 2017-10-10 08:45:00 2017-10-10 09:00:00 15 ## 6 300000… 03 2 2017-10-10 14:30:00 2017-10-10 14:45:00 15 ## 7 300000… 01 1 2017-10-10 11:15:00 2017-10-10 11:30:00 15 ## 8 300000… 01 2 2017-10-10 23:30:00 2017-10-10 23:40:00 10 ## 9 300000… 01 1 2017-10-10 05:50:00 2017-10-10 06:05:00 15 ## 10 300000… 01 2 2017-10-10 07:00:00 2017-10-10 07:15:00 15 ## # … with 923,562 more rows, and 56 more variables: trpmiles &lt;dbl+lbl&gt;, ## # trptrans &lt;chr+lbl&gt;, trpaccmp &lt;dbl+lbl&gt;, trphhacc &lt;dbl+lbl&gt;, ## # vehid &lt;chr+lbl&gt;, trwaittm &lt;dbl+lbl&gt;, numtrans &lt;dbl+lbl&gt;, tracctm &lt;dbl+lbl&gt;, ## # drop_prk &lt;chr+lbl&gt;, tregrtm &lt;dbl+lbl&gt;, whodrove &lt;chr+lbl&gt;, ## # whyfrom &lt;chr+lbl&gt;, loop_trip &lt;chr+lbl&gt;, trphhveh &lt;chr+lbl&gt;, ## # hhmemdrv &lt;chr+lbl&gt;, hh_ontd &lt;dbl+lbl&gt;, nonhhcnt &lt;dbl+lbl&gt;, ## # numontrp &lt;dbl+lbl&gt;, psgr_flg &lt;chr+lbl&gt;, pubtrans &lt;chr+lbl&gt;, ## # trippurp &lt;chr+lbl&gt;, dweltime &lt;dbl+lbl&gt;, tdwknd &lt;chr+lbl&gt;, ## # vmt_mile &lt;dbl+lbl&gt;, drvr_flg &lt;chr+lbl&gt;, whytrp1s &lt;chr+lbl&gt;, ## # ontd_p1 &lt;chr+lbl&gt;, ontd_p2 &lt;chr+lbl&gt;, ontd_p3 &lt;chr+lbl&gt;, ontd_p4 &lt;chr+lbl&gt;, ## # ontd_p5 &lt;chr+lbl&gt;, ontd_p6 &lt;chr+lbl&gt;, ontd_p7 &lt;chr+lbl&gt;, ontd_p8 &lt;chr+lbl&gt;, ## # ontd_p9 &lt;chr+lbl&gt;, ontd_p10 &lt;chr+lbl&gt;, ontd_p11 &lt;chr+lbl&gt;, ## # ontd_p12 &lt;chr+lbl&gt;, ontd_p13 &lt;chr+lbl&gt;, tdcaseid &lt;chr&gt;, ## # tracc_wlk &lt;chr+lbl&gt;, tracc_pov &lt;chr+lbl&gt;, tracc_bus &lt;chr+lbl&gt;, ## # tracc_crl &lt;chr+lbl&gt;, tracc_sub &lt;chr+lbl&gt;, tracc_oth &lt;chr+lbl&gt;, ## # tregr_wlk &lt;chr+lbl&gt;, tregr_pov &lt;chr+lbl&gt;, tregr_bus &lt;chr+lbl&gt;, ## # tregr_crl &lt;chr+lbl&gt;, tregr_sub &lt;chr+lbl&gt;, tregr_oth &lt;chr+lbl&gt;, ## # whyto &lt;chr+lbl&gt;, gasprice &lt;chr&gt;, wttrdfin &lt;dbl&gt;, whytrp90 &lt;chr+lbl&gt; B.4.2.1 Select, Filter, and Chains This table is pretty overwhelming. But there are two functions that can help us pare it down: select() lets you select columns in a table using the names of the columns. filter() lets you select rows in a table that meet a certain condition. Let’s practice this by selecting our trips dataset to only include the id columns, the trip length, and the trip purpose. select(trips, houseid, personid, trpmiles, trippurp) ## # A tibble: 923,572 x 4 ## houseid personid trpmiles trippurp ## &lt;chr&gt; &lt;chr&gt; &lt;dbl+lbl&gt; &lt;chr+lbl&gt; ## 1 30000007 01 5.24 HBO [Home-based trip (other)] ## 2 30000007 01 5.15 HBO [Home-based trip (other)] ## 3 30000007 02 84.0 HBW [Home-based trip (work)] ## 4 30000007 02 81.6 HBW [Home-based trip (work)] ## 5 30000007 03 2.25 HBO [Home-based trip (other)] ## 6 30000007 03 2.24 HBO [Home-based trip (other)] ## 7 30000008 01 8.02 HBW [Home-based trip (work)] ## 8 30000008 01 8.02 HBW [Home-based trip (work)] ## 9 30000012 01 3.40 HBSOCREC [Home-based trip (social/recreational)] ## 10 30000012 01 3.40 HBSOCREC [Home-based trip (social/recreational)] ## # … with 923,562 more rows Let’s also practice filtering the trips dataset to only include trips of the purpose “HBO” (home-based other). Notice how the number of rows in the table trips is much smaller. filter(trips, trippurp == &quot;HBW&quot;) # use double equals as comparison ## # A tibble: 117,368 x 62 ## houseid personid tdtrpnum strttime endtime trvlcmin ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;dttm&gt; &lt;dbl&gt; ## 1 300000… 02 1 2017-10-10 07:00:00 2017-10-10 09:00:00 120 ## 2 300000… 02 2 2017-10-10 18:00:00 2017-10-10 20:30:00 150 ## 3 300000… 01 1 2017-10-10 11:15:00 2017-10-10 11:30:00 15 ## 4 300000… 01 2 2017-10-10 23:30:00 2017-10-10 23:40:00 10 ## 5 300000… 01 5 2017-10-10 09:00:00 2017-10-10 09:20:00 20 ## 6 300000… 01 7 2017-10-10 15:30:00 2017-10-10 16:05:00 35 ## 7 300000… 01 1 2017-10-10 08:00:00 2017-10-10 08:20:00 20 ## 8 300000… 01 2 2017-10-10 18:00:00 2017-10-10 20:00:00 120 ## 9 300000… 02 3 2017-10-10 09:00:00 2017-10-10 11:00:00 120 ## 10 300000… 02 4 2017-10-10 18:30:00 2017-10-10 20:30:00 120 ## # … with 117,358 more rows, and 56 more variables: trpmiles &lt;dbl&gt;, ## # trptrans &lt;chr&gt;, trpaccmp &lt;dbl&gt;, trphhacc &lt;dbl&gt;, vehid &lt;chr&gt;, ## # trwaittm &lt;dbl&gt;, numtrans &lt;dbl&gt;, tracctm &lt;dbl&gt;, drop_prk &lt;chr&gt;, ## # tregrtm &lt;dbl&gt;, whodrove &lt;chr&gt;, whyfrom &lt;chr&gt;, loop_trip &lt;chr&gt;, ## # trphhveh &lt;chr&gt;, hhmemdrv &lt;chr&gt;, hh_ontd &lt;dbl&gt;, nonhhcnt &lt;dbl&gt;, ## # numontrp &lt;dbl&gt;, psgr_flg &lt;chr&gt;, pubtrans &lt;chr&gt;, trippurp &lt;chr&gt;, ## # dweltime &lt;dbl&gt;, tdwknd &lt;chr&gt;, vmt_mile &lt;dbl&gt;, drvr_flg &lt;chr&gt;, ## # whytrp1s &lt;chr&gt;, ontd_p1 &lt;chr&gt;, ontd_p2 &lt;chr&gt;, ontd_p3 &lt;chr&gt;, ontd_p4 &lt;chr&gt;, ## # ontd_p5 &lt;chr&gt;, ontd_p6 &lt;chr&gt;, ontd_p7 &lt;chr&gt;, ontd_p8 &lt;chr&gt;, ontd_p9 &lt;chr&gt;, ## # ontd_p10 &lt;chr&gt;, ontd_p11 &lt;chr&gt;, ontd_p12 &lt;chr&gt;, ontd_p13 &lt;chr&gt;, ## # tdcaseid &lt;chr&gt;, tracc_wlk &lt;chr&gt;, tracc_pov &lt;chr&gt;, tracc_bus &lt;chr&gt;, ## # tracc_crl &lt;chr&gt;, tracc_sub &lt;chr&gt;, tracc_oth &lt;chr&gt;, tregr_wlk &lt;chr&gt;, ## # tregr_pov &lt;chr&gt;, tregr_bus &lt;chr&gt;, tregr_crl &lt;chr&gt;, tregr_sub &lt;chr&gt;, ## # tregr_oth &lt;chr&gt;, whyto &lt;chr&gt;, gasprice &lt;chr&gt;, wttrdfin &lt;dbl&gt;, ## # whytrp90 &lt;chr&gt; One extremely useful feature of the tidyverse functions is the chain operator, %&gt;%. This operator basically does the opposite of the assigment operator &lt;-. While assignment says “take the thing on the right and put it in the thing on the left,” chain says “take the thing on the left and pass it as the first argument of the function on the right.” What this means in practice is we can chain R commands together. So we can do the select and the filter statements in sequence, trips %&gt;% select(houseid, personid, trpmiles, trippurp) %&gt;% filter(trippurp == &quot;HBW&quot;) ## # A tibble: 117,368 x 4 ## houseid personid trpmiles trippurp ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 30000007 02 84.0 HBW ## 2 30000007 02 81.6 HBW ## 3 30000008 01 8.02 HBW ## 4 30000008 01 8.02 HBW ## 5 30000012 01 4.29 HBW ## 6 30000012 01 6.82 HBW ## 7 30000039 01 11.5 HBW ## 8 30000041 01 73.7 HBW ## 9 30000041 02 77.9 HBW ## 10 30000041 02 77.8 HBW ## # … with 117,358 more rows Notice that we didn’t have to tell the select and filter functions the name of the table we were selecting or filtering. The %&gt;% chain operator did that for us. Once we have the table we want, we can assign it to a new object called mytrips In this case, let’s get HBO and HBW trips. mytrips &lt;- trips %&gt;% select(houseid, personid, trpmiles, trippurp) %&gt;% filter(trippurp %in% c(&quot;HBW&quot;, &quot;HBO&quot;)) # use %in% for multiple comparisons. B.4.3 Mutate, Summarize, and Group Sometimes we want to calculate a new column in a table, or recompute an existing column. We can do that with the mutate function, and we can put more than one calculation in a single mutate statement. mytrips %&gt;% mutate( tripkm = trpmiles * 1.60934, # convert miles to km. longtrip = ifelse(tripkm &gt; 50, TRUE, FALSE) # is trip longer than 50 km? ) ## # A tibble: 307,390 x 6 ## houseid personid trpmiles trippurp tripkm longtrip ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 30000007 01 5.24 HBO 8.44 FALSE ## 2 30000007 01 5.15 HBO 8.29 FALSE ## 3 30000007 02 84.0 HBW 135. TRUE ## 4 30000007 02 81.6 HBW 131. TRUE ## 5 30000007 03 2.25 HBO 3.62 FALSE ## 6 30000007 03 2.24 HBO 3.61 FALSE ## 7 30000008 01 8.02 HBW 12.9 FALSE ## 8 30000008 01 8.02 HBW 12.9 FALSE ## 9 30000012 01 4.29 HBW 6.91 FALSE ## 10 30000012 01 6.82 HBW 11.0 FALSE ## # … with 307,380 more rows Other times we want to calculate summary statistics like means. For this we can use the summarize() function. mytrips %&gt;% summarize( mean_trip = mean(trpmiles), sd_trip = sd(trpmiles), max_trip = max(trpmiles), min_trip = min(trpmiles) ) ## # A tibble: 1 x 4 ## mean_trip sd_trip max_trip min_trip ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 9.81 32.1 5699. -9 Finally, we sometimes want to calculate summary statistics for different groups. We can tell tidyverse to group our tables with the group_by() function. mytrips %&gt;% group_by(trippurp) %&gt;% summarize( mean_trip = mean(trpmiles), sd_trip = sd(trpmiles), max_trip = max(trpmiles), min_trip = min(trpmiles) ) ## # A tibble: 2 x 5 ## trippurp mean_trip sd_trip max_trip min_trip ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 HBO 7.73 32.0 5699. -9 ## 2 HBW 13.2 31.9 2927. -9 As you might expect, work trips are on average longer than other kinds of trips. But some people report very long trips! You might want to filter your data more carefully for real analyses. B.5 Graphics with ggplot2 The ggplot2 package included in the tidyverse is a very powerful graphics engine with a relatively easy-to-learn grammar. In fact, the gg stands for “grammar of graphics” as it implements the grammar defined by Wilkinson (2012). The basic structure of a ggplot2 call is constructed as follows: ggplot(data, aes(data aesthetics like x and y coordinates, fill color, etc.)) + geom_(geometry style like point, bar, or histogram) + other things like theme, color, and labels For instance, we can create a histogram of trip lengths in the NHTS by giving the x aesthetic as the trpmiles column in the mytrips dataset. ggplot(mytrips, aes(x = trpmiles)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. This ends up not being very informative because some trips are very long. We could filter out the long trips within the data argument (Note that we still have the -9 values from the missing information). ggplot(mytrips %&gt;% filter(trpmiles &lt; 50), aes(x = trpmiles)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. If we wanted to see the difference between lengths of different trip purposes, we could add a color aesthetic to the plot. By default this stacks the two categories on top of each other. ggplot(mytrips %&gt;% filter(trpmiles &lt; 50), aes(x = trpmiles, fill = trippurp)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. You could also show this with a statistical density (the integral of a density function is 1). Note that the alpha statement for fill opacity is not included as an aesthetic, because it doesn’t vary based on any data elements in the way that the x and fill variables do. ggplot(mytrips %&gt;% filter(trpmiles &lt; 50), aes(x = trpmiles, fill = trippurp)) + geom_density(alpha = 0.5) ggplot2 also excels at building statistical analysis on top of visualization. For example, we can see the odometer reading for cars still on the road in 2017 by make. set.seed(15) # so that we pull the same random records each time # sample 15k vehicles built after 1980 with 0 to 500k miles vehicles &lt;- nhts_vehicles %&gt;% # convert numeric make to its labeled name, and then group into manufacturers mutate( make = as_factor(make, levels = &quot;labels&quot;), vehtype = as_factor(vehtype, levels = &quot;labels&quot;), make = case_when( make %in% c(&quot;Toyota&quot;, &quot;Lexus&quot;, &quot;Subaru&quot;) ~ &quot;Toyota&quot;, make %in% c(&quot;Ford&quot;, &quot;Lincoln&quot;, &quot;Mercury&quot;) ~ &quot;Ford&quot;, make %in% c(&quot;Chevrolet&quot;, &quot;GMC&quot;, &quot;Pontiac&quot;, &quot;Buick&quot;, &quot;Cadillac&quot;, &quot;Saturn&quot;) ~ &quot;GM&quot;, make %in% c(&quot;Volkswagen&quot;, &quot;Audi&quot;, &quot;Porsche&quot;) ~ &quot;VW&quot;, grepl(&quot;Jeep&quot;, make) | grepl(&quot;Chrysler&quot;, make) | make %in% c(&quot;Ram&quot;, &quot;Dodge&quot;, &quot;Plymouth&quot;) ~ &quot;Chrysler&quot;, make %in% c(&quot;Honda&quot;, &quot;Acura&quot;) ~ &quot;Honda&quot;, make %in% c(&quot;Nissan/Datsun&quot;, &quot;Infiniti&quot;) ~ &quot;Nissan&quot;, TRUE ~ &quot;Other&quot; # all other makes ) , vehtype = case_when( grepl(&quot;Car&quot;, vehtype) ~ &quot;Car&quot;, grepl(&quot;Van&quot;, vehtype) ~ &quot;Van&quot;, grepl(&quot;SUV&quot;, vehtype) ~ &quot;SUV&quot;, grepl(&quot;Pickup&quot;, vehtype) ~ &quot;Pickup&quot;, TRUE ~ &quot;Other&quot;, ) ) %&gt;% filter(vehtype != &quot;Other&quot;) %&gt;% filter(vehyear &gt; 1980) %&gt;% filter(od_read &gt; 0, od_read &lt; 500000) %&gt;% sample_n(15000) ggplot(vehicles, aes(x = vehyear, y = od_read, color = make)) + geom_point() This is pretty unreadable. But we can add a few things to the figure to make it a little bit easier to understand, like smooth average lines and point transparency. ggplot(vehicles, aes(x = vehyear, y = od_read, color = make)) + geom_point(alpha = 0.5) + stat_smooth(method = &quot;loess&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; Let’s break this out by vehicle type. ggplot(vehicles, aes(x = vehyear, y = od_read, color = make)) + geom_point(alpha = 0.5) + stat_smooth(method = &quot;loess&quot;) + facet_wrap(~vehtype) ## `geom_smooth()` using formula &#39;y ~ x&#39; And let’s clean it up a little bit. This is a figure that you could put in a published journal article or thesis, if it showed something you cared to show. ggplot(vehicles, aes(x = vehyear, y = od_read, color = make)) + geom_point(alpha = 0.5) + scale_color_discrete(&quot;Manufacturer&quot;) + stat_smooth(method = &quot;loess&quot;) + facet_wrap(~vehtype) + xlab(&quot;Vehicle Model Year&quot;) + ylab(&quot;Odometer Reading&quot;) + theme_bw() ## `geom_smooth()` using formula &#39;y ~ x&#39; "]
]
